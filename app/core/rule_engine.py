from typing import Tuple, Optional
from app.ml.feature_extractor import FeatureExtractor
from app.config import settings

class RuleEngine:
    """Heuristic-based rule engine for fast DNS filtering"""
    
    def __init__(self):
        self.feature_extractor = FeatureExtractor()
        self.whitelist = set()
        self.blacklist = set()
    
    def load_lists(self, whitelist: set, blacklist: set):
        """Load whitelist and blacklist"""
        self.whitelist = whitelist
        self.blacklist = blacklist
    
    def check_domain(self, domain: str) -> Tuple[str, float, str]:
        """
        Check domain against heuristic rules
        
        Args:
            domain: Domain name to check
            
        Returns:
            Tuple of (decision, confidence, reason)
            - decision: "ALLOW", "BLOCK", or "UNCERTAIN"
            - confidence: 0.0 to 1.0
            - reason: Human-readable explanation
        """
        domain = domain.lower().strip()
        
        # Check whitelist first (highest priority)
        if domain in self.whitelist:
            return "ALLOW", 1.0, "Domain is whitelisted"
        
        # Check blacklist
        if domain in self.blacklist:
            return "BLOCK", 1.0, "Domain is blacklisted"
        
        # Extract features for analysis
        features = self.feature_extractor.extract_features(domain)
        
        # Calculate risk score based on multiple factors
        risk_score = 0
        reasons = []
        
        # 1. Length check
        if features['length'] > settings.RULE_MAX_DOMAIN_LENGTH:
            risk_score += 2
            reasons.append("unusually long domain")
        
        if features['length'] < 4:
            risk_score += 1
            reasons.append("very short domain")
        
        # 2. TLD check
        if features['tld_risk_score'] >= 5:
            risk_score += 3
            reasons.append("suspicious TLD")
        elif features['tld_risk_score'] >= 3:
            risk_score += 1
            reasons.append("uncommon TLD")
        
        # 3. Entropy check (randomness)
        if features['entropy'] > settings.RULE_HIGH_ENTROPY_THRESHOLD:
            risk_score += 2
            reasons.append("high entropy (random-looking)")
        
        # 4. Digit ratio
        if features['digit_ratio'] > 0.3:
            risk_score += 2
            reasons.append("high digit ratio")
        
        # 5. Special characters
        if features['hyphen_count'] > 3:
            risk_score += 1
            reasons.append("many hyphens")
        
        if features['special_char_ratio'] > 0.15:
            risk_score += 1
            reasons.append("many special characters")
        
        # 6. Suspicious patterns
        if features['has_suspicious_keyword']:
            risk_score += 2
            reasons.append("contains suspicious keywords")
        
        if features['has_ip_pattern']:
            risk_score += 2
            reasons.append("contains IP address pattern")
        
        if features['has_hex_pattern']:
            risk_score += 1
            reasons.append("contains hexadecimal pattern")
        
        # 7. Subdomain depth
        if features['subdomain_count'] > 4:
            risk_score += 1
            reasons.append("deep subdomain structure")
        
        # 8. Consonant sequence (hard to pronounce = suspicious)
        if features['max_consonant_sequence'] > 7:
            risk_score += 1
            reasons.append("long consonant sequence")
        
        # 9. Vowel/consonant ratio
        if features['vowel_consonant_ratio'] < 0.2 or features['vowel_consonant_ratio'] > 3.0:
            risk_score += 1
            reasons.append("unusual vowel/consonant ratio")
        
        # Make decision based on risk score
        if risk_score >= 6:
            reason = "High risk: " + ", ".join(reasons)
            return "BLOCK", min(0.95, 0.6 + (risk_score * 0.05)), reason
        
        elif risk_score >= 3:
            reason = "Medium risk: " + ", ".join(reasons)
            return "UNCERTAIN", 0.5 + (risk_score * 0.05), reason
        
        else:
            if reasons:
                reason = "Low risk: " + ", ".join(reasons)
            else:
                reason = "No suspicious indicators"
            return "ALLOW", max(0.1, 0.95 - (risk_score * 0.1)), reason
    
    def is_likely_dga(self, domain: str) -> bool:
        """
        Check if domain is likely generated by DGA (Domain Generation Algorithm)
        
        DGA characteristics:
        - High entropy
        - Random-looking characters
        - Unusual character distribution
        """
        features = self.feature_extractor.extract_features(domain)
        
        dga_indicators = 0
        
        if features['entropy'] > 4.5:
            dga_indicators += 1
        
        if features['max_consonant_sequence'] > 8:
            dga_indicators += 1
        
        if features['vowel_consonant_ratio'] < 0.15:
            dga_indicators += 1
        
        if features['digit_ratio'] > 0.2 and features['length'] > 15:
            dga_indicators += 1
        
        return dga_indicators >= 2
    
    def analyze_typosquatting(self, domain: str, trusted_domains: list) -> Optional[str]:
        """
        Check if domain is similar to trusted domains (typosquatting detection)
        
        Args:
            domain: Domain to check
            trusted_domains: List of legitimate domains
            
        Returns:
            Similar domain if found, None otherwise
        """
        from difflib import SequenceMatcher
        
        domain_name = domain.split('.')[0]
        
        for trusted in trusted_domains:
            trusted_name = trusted.split('.')[0]
            
            # Calculate similarity
            similarity = SequenceMatcher(None, domain_name, trusted_name).ratio()
            
            # If very similar but not exact match
            if 0.75 < similarity < 1.0:
                return trusted
        
        return None